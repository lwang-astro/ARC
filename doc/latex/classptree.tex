\hypertarget{classptree}{}\section{ptree$<$ particle, proc\+\_\+params $>$ Class Template Reference}
\label{classptree}\index{ptree$<$ particle, proc\+\_\+params $>$@{ptree$<$ particle, proc\+\_\+params $>$}}


Class to make hierarchical N-\/body systems.  




{\ttfamily \#include $<$ptree.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef particle($\ast$ \hyperlink{classptree_a5dce5bec8c21e2bfb68446434e95d21a}{pair\+\_\+proc\+\_\+function}) (const std\+::size\+\_\+t id, const std\+::size\+\_\+t ib, particle $\ast$c\mbox{[}$\,$\mbox{]}, proc\+\_\+params \&pars)
\begin{DoxyCompactList}\small\item\em typedef of pair processing function \end{DoxyCompactList}\item 
typedef particle($\ast$ \hyperlink{classptree_abbd858cc881219618a3ac42f3df11cc6}{particle\+\_\+shift}) (const particle \&a, const particle \&ref)
\begin{DoxyCompactList}\small\item\em typedef of particle shifting function used during split \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classptree_a128cebcb837edbd16dd6dd9c7784ddd9}{ptree} (const particle \&a, const particle \&b)
\begin{DoxyCompactList}\small\item\em construct the tree py filling two particles \end{DoxyCompactList}\item 
\hyperlink{classptree_afcae2407c3b390bf0d7579951bd96961}{ptree} ()
\item 
\hyperlink{classptree_a7f4dd129764d06800dbadb91ed88a62c}{$\sim$ptree} ()
\item 
void \hyperlink{classptree_aa7b4caa59ef84eca62433a9621dcfb1b}{clear} ()
\item 
bool \hyperlink{classptree_a296d5895fbf14f2bb3af6ebf2fa52164}{fill} (const particle \&a, const particle \&b)
\begin{DoxyCompactList}\small\item\em fill particles to two leaves/branches \end{DoxyCompactList}\item 
bool \hyperlink{classptree_ae4c20eddf5cfcf45e5f809567c967bf9}{split} (const std\+::size\+\_\+t i, const particle \&a, const particle \&b, \hyperlink{classptree_abbd858cc881219618a3ac42f3df11cc6}{particle\+\_\+shift} pshift)
\begin{DoxyCompactList}\small\item\em Split (delete) one leaf, create a new branch (ptree) and store two particles. \end{DoxyCompactList}\item 
bool \hyperlink{classptree_a84643c9c87f4ed74ec06542e22c8bee7}{link} (const std\+::size\+\_\+t id, const std\+::size\+\_\+t ib, const particle \&a, const particle \&b, \hyperlink{classptree_abbd858cc881219618a3ac42f3df11cc6}{particle\+\_\+shift} pshift)
\begin{DoxyCompactList}\small\item\em add a particle pair to one of the leaf \end{DoxyCompactList}\item 
int \hyperlink{classptree_a0739f9513c8fe3fece542513b9ed48de}{collect\+\_\+and\+\_\+store} (particle plist\mbox{[}$\,$\mbox{]}, const int n)
\begin{DoxyCompactList}\small\item\em collect particles into plist and map addresses to it \end{DoxyCompactList}\item 
int \hyperlink{classptree_a84576b8523ff7b4f90711fd18e6d0e22}{collect} (particle $\ast$plist\mbox{[}$\,$\mbox{]}, const int n)
\begin{DoxyCompactList}\small\item\em collect particles into plist \end{DoxyCompactList}\item 
particle \hyperlink{classptree_ac8d6f27b2accf46a78dd865093af7849}{pair\+\_\+process} (const std\+::size\+\_\+t id, const std\+::size\+\_\+t ib, \hyperlink{classptree_a5dce5bec8c21e2bfb68446434e95d21a}{pair\+\_\+proc\+\_\+function} f, proc\+\_\+params \&pars)
\begin{DoxyCompactList}\small\item\em Apply functions to pairs in the trees. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class particle, class proc\+\_\+params$>$\\*
class ptree$<$ particle, proc\+\_\+params $>$}

Class to make hierarchical N-\/body systems. 

Depend on templete class particle and pair processing function parameters proc\+\_\+params 

\subsection{Member Typedef Documentation}
\index{ptree@{ptree}!pair\+\_\+proc\+\_\+function@{pair\+\_\+proc\+\_\+function}}
\index{pair\+\_\+proc\+\_\+function@{pair\+\_\+proc\+\_\+function}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{pair\+\_\+proc\+\_\+function}{pair_proc_function}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ typedef particle($\ast$ {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::pair\+\_\+proc\+\_\+function) (const std\+::size\+\_\+t id, const std\+::size\+\_\+t ib, particle $\ast$c\mbox{[}$\,$\mbox{]}, proc\+\_\+params \&pars)}\hypertarget{classptree_a5dce5bec8c21e2bfb68446434e95d21a}{}\label{classptree_a5dce5bec8c21e2bfb68446434e95d21a}


typedef of pair processing function 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em id} & current tree depth (root is 0) \\
\hline
\mbox{\tt in}  & {\em ib} & current leaf index (count from left to right, total size is $ 2^{id} $ \\
\hline
\mbox{\tt in}  & {\em c} & two particle pointer to the two pair members \\
\hline
\mbox{\tt in,out}  & {\em pars} & proc\+\_\+params type parameters used in the processing function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: new particle generated by the function (e.\+g. center-\/of-\/mass particle) 
\end{DoxyReturn}
\index{ptree@{ptree}!particle\+\_\+shift@{particle\+\_\+shift}}
\index{particle\+\_\+shift@{particle\+\_\+shift}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{particle\+\_\+shift}{particle_shift}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ typedef particle($\ast$ {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::particle\+\_\+shift) (const particle \&a, const particle \&ref)}\hypertarget{classptree_abbd858cc881219618a3ac42f3df11cc6}{}\label{classptree_abbd858cc881219618a3ac42f3df11cc6}


typedef of particle shifting function used during split 

Split function create new branch with two particles, when the two particles are stored, they are applied ths shifting function by referring the old particle stored in the leaf 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & particle need to be shifted \\
\hline
\mbox{\tt in}  & {\em ref} & reference paraticle \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: new particle 
\end{DoxyReturn}


\subsection{Constructor \& Destructor Documentation}
\index{ptree@{ptree}!ptree@{ptree}}
\index{ptree@{ptree}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{ptree(const particle \&a, const particle \&b)}{ptree(const particle &a, const particle &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::{\bf ptree} (
\begin{DoxyParamCaption}
\item[{const particle \&}]{a, }
\item[{const particle \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_a128cebcb837edbd16dd6dd9c7784ddd9}{}\label{classptree_a128cebcb837edbd16dd6dd9c7784ddd9}


construct the tree py filling two particles 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & particle one to left leaf \\
\hline
\mbox{\tt in}  & {\em b} & particle two to right leaf \\
\hline
\end{DoxyParams}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{classptree_a128cebcb837edbd16dd6dd9c7784ddd9_cgraph}
\end{center}
\end{figure}


\index{ptree@{ptree}!ptree@{ptree}}
\index{ptree@{ptree}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{ptree()}{ptree()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::{\bf ptree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_afcae2407c3b390bf0d7579951bd96961}{}\label{classptree_afcae2407c3b390bf0d7579951bd96961}
\index{ptree@{ptree}!````~ptree@{$\sim$ptree}}
\index{````~ptree@{$\sim$ptree}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{$\sim$ptree()}{~ptree()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::$\sim${\bf ptree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_a7f4dd129764d06800dbadb91ed88a62c}{}\label{classptree_a7f4dd129764d06800dbadb91ed88a62c}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=269pt]{classptree_a7f4dd129764d06800dbadb91ed88a62c_cgraph}
\end{center}
\end{figure}




\subsection{Member Function Documentation}
\index{ptree@{ptree}!clear@{clear}}
\index{clear@{clear}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ void {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_aa7b4caa59ef84eca62433a9621dcfb1b}{}\label{classptree_aa7b4caa59ef84eca62433a9621dcfb1b}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=269pt]{classptree_aa7b4caa59ef84eca62433a9621dcfb1b_icgraph}
\end{center}
\end{figure}


\index{ptree@{ptree}!collect@{collect}}
\index{collect@{collect}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{collect(particle $\ast$plist[], const int n)}{collect(particle *plist[], const int n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ int {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::collect (
\begin{DoxyParamCaption}
\item[{particle $\ast$}]{plist\mbox{[}$\,$\mbox{]}, }
\item[{const int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_a84576b8523ff7b4f90711fd18e6d0e22}{}\label{classptree_a84576b8523ff7b4f90711fd18e6d0e22}


collect particles into plist 

Scan tree and store particle address into plist. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em plist} & particle address array \\
\hline
\mbox{\tt in}  & {\em n} & plist array size (maximum particle number that can be stored) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
remaining empty number in plist 
\end{DoxyReturn}
\index{ptree@{ptree}!collect\+\_\+and\+\_\+store@{collect\+\_\+and\+\_\+store}}
\index{collect\+\_\+and\+\_\+store@{collect\+\_\+and\+\_\+store}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{collect\+\_\+and\+\_\+store(particle plist[], const int n)}{collect_and_store(particle plist[], const int n)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ int {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::collect\+\_\+and\+\_\+store (
\begin{DoxyParamCaption}
\item[{particle}]{plist\mbox{[}$\,$\mbox{]}, }
\item[{const int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_a0739f9513c8fe3fece542513b9ed48de}{}\label{classptree_a0739f9513c8fe3fece542513b9ed48de}


collect particles into plist and map addresses to it 

Scan tree and push back particles into plist, then delete the branch particle and link the corresponding particle address in plist. This means the data memory is moved from tree leafs to plist array. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em plist} & particle type data array \\
\hline
\mbox{\tt in}  & {\em n} & plist array size (maximum particle number that can be stored) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
remaining empty number in plist (if return value is -\/1\+: collection failed) 
\end{DoxyReturn}
\index{ptree@{ptree}!fill@{fill}}
\index{fill@{fill}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{fill(const particle \&a, const particle \&b)}{fill(const particle &a, const particle &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ bool {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::fill (
\begin{DoxyParamCaption}
\item[{const particle \&}]{a, }
\item[{const particle \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_a296d5895fbf14f2bb3af6ebf2fa52164}{}\label{classptree_a296d5895fbf14f2bb3af6ebf2fa52164}


fill particles to two leaves/branches 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em a} & left particle \\
\hline
\mbox{\tt in}  & {\em b} & right particle \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the branches are already filled (failure), return false, else true 
\end{DoxyReturn}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{classptree_a296d5895fbf14f2bb3af6ebf2fa52164_icgraph}
\end{center}
\end{figure}


\index{ptree@{ptree}!link@{link}}
\index{link@{link}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{link(const std\+::size\+\_\+t id, const std\+::size\+\_\+t ib, const particle \&a, const particle \&b, particle\+\_\+shift pshift)}{link(const std::size_t id, const std::size_t ib, const particle &a, const particle &b, particle_shift pshift)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ bool {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::link (
\begin{DoxyParamCaption}
\item[{const std\+::size\+\_\+t}]{id, }
\item[{const std\+::size\+\_\+t}]{ib, }
\item[{const particle \&}]{a, }
\item[{const particle \&}]{b, }
\item[{{\bf particle\+\_\+shift}}]{pshift}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_a84643c9c87f4ed74ec06542e22c8bee7}{}\label{classptree_a84643c9c87f4ed74ec06542e22c8bee7}


add a particle pair to one of the leaf 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em id} & depth of the tree, top is 0 \\
\hline
\mbox{\tt in}  & {\em ib} & leaf index, counting from 0 from left to right (maximum index $ 2^{id} $) \\
\hline
\mbox{\tt in}  & {\em a} & particle one \\
\hline
\mbox{\tt in}  & {\em b} & particle two \\
\hline
\mbox{\tt in}  & {\em pshift} & particle shifting function applied to the two particles referring to the origin particle stored at the splitted leaf. The two new particles generated will be stored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true\+: successful adding 
\end{DoxyReturn}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{classptree_a84643c9c87f4ed74ec06542e22c8bee7_cgraph}
\end{center}
\end{figure}


\index{ptree@{ptree}!pair\+\_\+process@{pair\+\_\+process}}
\index{pair\+\_\+process@{pair\+\_\+process}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{pair\+\_\+process(const std\+::size\+\_\+t id, const std\+::size\+\_\+t ib, pair\+\_\+proc\+\_\+function f, proc\+\_\+params \&pars)}{pair_process(const std::size_t id, const std::size_t ib, pair_proc_function f, proc_params &pars)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ particle {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::pair\+\_\+process (
\begin{DoxyParamCaption}
\item[{const std\+::size\+\_\+t}]{id, }
\item[{const std\+::size\+\_\+t}]{ib, }
\item[{{\bf pair\+\_\+proc\+\_\+function}}]{f, }
\item[{proc\+\_\+params \&}]{pars}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_ac8d6f27b2accf46a78dd865093af7849}{}\label{classptree_ac8d6f27b2accf46a78dd865093af7849}


Apply functions to pairs in the trees. 

\index{ptree@{ptree}!split@{split}}
\index{split@{split}!ptree@{ptree}}
\subsubsection[{\texorpdfstring{split(const std\+::size\+\_\+t i, const particle \&a, const particle \&b, particle\+\_\+shift pshift)}{split(const std::size_t i, const particle &a, const particle &b, particle_shift pshift)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class particle , class proc\+\_\+params $>$ bool {\bf ptree}$<$ particle, proc\+\_\+params $>$\+::split (
\begin{DoxyParamCaption}
\item[{const std\+::size\+\_\+t}]{i, }
\item[{const particle \&}]{a, }
\item[{const particle \&}]{b, }
\item[{{\bf particle\+\_\+shift}}]{pshift}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classptree_ae4c20eddf5cfcf45e5f809567c967bf9}{}\label{classptree_ae4c20eddf5cfcf45e5f809567c967bf9}


Split (delete) one leaf, create a new branch (ptree) and store two particles. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em i} & leaf index (0\+: left; 1\+: right; others return false) \\
\hline
\mbox{\tt in}  & {\em a} & left paricle \\
\hline
\mbox{\tt in}  & {\em b} & right particle \\
\hline
\mbox{\tt in}  & {\em pshift} & particle shifting function applied to the two particles referring to the origin particle before storing \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the branch are successfully created and filled return true, otherwise return false 
\end{DoxyReturn}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=242pt]{classptree_ae4c20eddf5cfcf45e5f809567c967bf9_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=248pt]{classptree_ae4c20eddf5cfcf45e5f809567c967bf9_icgraph}
\end{center}
\end{figure}




The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/mnt/c/\+Users/longw/\+Documents/\+Git\+Hub/\+A\+R\+C/include/\hyperlink{ptree_8h}{ptree.\+h}\end{DoxyCompactItemize}
