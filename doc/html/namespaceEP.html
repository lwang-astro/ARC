<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithmic Regularization Chain (ARC): EP Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithmic Regularization Chain (ARC)
   </div>
   <div id="projectbrief">Algorithmic Regularization Chain for few body motions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceEP.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EP Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>For extrapolation related functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6197a74bc7ca232ffcc84872d8f4f779"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a6197a74bc7ca232ffcc84872d8f4f779">seq_Harmonic</a> (int step[], const std::size_t itermax)</td></tr>
<tr class="memdesc:a6197a74bc7ca232ffcc84872d8f4f779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Harmonic sequence {h, h/2, h/3, h/4 ...}.  <a href="#a6197a74bc7ca232ffcc84872d8f4f779">More...</a><br /></td></tr>
<tr class="separator:a6197a74bc7ca232ffcc84872d8f4f779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaef3617ed3fb4ad4627c19e955c5457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#afaef3617ed3fb4ad4627c19e955c5457">seq_Romberg</a> (int step[], const std::size_t itermax)</td></tr>
<tr class="memdesc:afaef3617ed3fb4ad4627c19e955c5457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Romberg (even) sequence {h, h/2, h/4, h/8 ...}.  <a href="#afaef3617ed3fb4ad4627c19e955c5457">More...</a><br /></td></tr>
<tr class="separator:afaef3617ed3fb4ad4627c19e955c5457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c85d6f300251929ac82736e54760652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a1c85d6f300251929ac82736e54760652">seq_BS</a> (int step[], const std::size_t itermax)</td></tr>
<tr class="memdesc:a1c85d6f300251929ac82736e54760652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Bulirsch &amp; Stoer sequence {h, h/2, h/3, h/4, h/6, h/8 ...}.  <a href="#a1c85d6f300251929ac82736e54760652">More...</a><br /></td></tr>
<tr class="separator:a1c85d6f300251929ac82736e54760652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691e74f494e1137b68389a2bd93f92c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a691e74f494e1137b68389a2bd93f92c0">seq_Hairer</a> (int step[], const std::size_t itermax)</td></tr>
<tr class="memdesc:a691e74f494e1137b68389a2bd93f92c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate E. Hairer (4k) sequences {h/2, h/6, h/10, h/14 ...}.  <a href="#a691e74f494e1137b68389a2bd93f92c0">More...</a><br /></td></tr>
<tr class="separator:a691e74f494e1137b68389a2bd93f92c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f951202841accc906325f37f9e592af"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a8f951202841accc906325f37f9e592af">polynomial_recursive_formula</a> (const double ti1k1, const double tik1, const double hr)</td></tr>
<tr class="memdesc:a8f951202841accc906325f37f9e592af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial_recursion_formula.  <a href="#a8f951202841accc906325f37f9e592af">More...</a><br /></td></tr>
<tr class="separator:a8f951202841accc906325f37f9e592af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6d08bb36343e39ebbbd4406dc9989f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#afe6d08bb36343e39ebbbd4406dc9989f">rational_recursive_formula</a> (const double ti1k2, const double ti1k1, const double tik1, const double hr)</td></tr>
<tr class="memdesc:afe6d08bb36343e39ebbbd4406dc9989f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational_recursion formula.  <a href="#afe6d08bb36343e39ebbbd4406dc9989f">More...</a><br /></td></tr>
<tr class="separator:afe6d08bb36343e39ebbbd4406dc9989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d6690a891336eef708e90e575a2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#ae89d6690a891336eef708e90e575a2be">polynomial_extrapolation</a> (double **Tn, double *Tnew, const int step[], const std::size_t Tsize, const std::size_t n)</td></tr>
<tr class="memdesc:ae89d6690a891336eef708e90e575a2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial extrapolation of Tsize number of data together.  <a href="#ae89d6690a891336eef708e90e575a2be">More...</a><br /></td></tr>
<tr class="separator:ae89d6690a891336eef708e90e575a2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069470acd4f6c52b2ebb68afcf4528ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a069470acd4f6c52b2ebb68afcf4528ab">rational_extrapolation</a> (double **Tn, double *Tnew, const int step[], const std::size_t Tsize, const std::size_t n)</td></tr>
<tr class="memdesc:a069470acd4f6c52b2ebb68afcf4528ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational extrapolation of Tsize number of data together.  <a href="#a069470acd4f6c52b2ebb68afcf4528ab">More...</a><br /></td></tr>
<tr class="separator:a069470acd4f6c52b2ebb68afcf4528ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0499a8ae6cab209fc0cca6a47b166f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#ab0499a8ae6cab209fc0cca6a47b166f3">extrapolation_error</a> (double **Tn, const std::size_t Tsize, const std::size_t n)</td></tr>
<tr class="memdesc:ab0499a8ae6cab209fc0cca6a47b166f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error estimation.  <a href="#ab0499a8ae6cab209fc0cca6a47b166f3">More...</a><br /></td></tr>
<tr class="separator:ab0499a8ae6cab209fc0cca6a47b166f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac820e20bad3526991885e767a4e11097"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#ac820e20bad3526991885e767a4e11097">H_opt_factor</a> (const double err, const double exp, const std::size_t n)</td></tr>
<tr class="memdesc:ac820e20bad3526991885e767a4e11097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next step optimized factor estimation (based on the extrapolation order n)  <a href="#ac820e20bad3526991885e767a4e11097">More...</a><br /></td></tr>
<tr class="separator:ac820e20bad3526991885e767a4e11097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c709f3757c872402d2fcf954c3e2de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a92c709f3757c872402d2fcf954c3e2de">binomial_recursive_generator</a> (int *bn, const int *bp, const std::size_t n)</td></tr>
<tr class="memdesc:a92c709f3757c872402d2fcf954c3e2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial coefficients generator.  <a href="#a92c709f3757c872402d2fcf954c3e2de">More...</a><br /></td></tr>
<tr class="separator:a92c709f3757c872402d2fcf954c3e2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bbde38ef63ce2a0672843d598770b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#ad1bbde38ef63ce2a0672843d598770b8">Hermite_interpolation_coefficients</a> (double **coff, const double *x, double **f, double ***df, const int ndata, const int npoints, const int *nlev)</td></tr>
<tr class="memdesc:ad1bbde38ef63ce2a0672843d598770b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermite interpolation coefficients.  <a href="#ad1bbde38ef63ce2a0672843d598770b8">More...</a><br /></td></tr>
<tr class="separator:ad1bbde38ef63ce2a0672843d598770b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10270a1ba230322545fff5bc06d94659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEP.html#a10270a1ba230322545fff5bc06d94659">Hermite_interpolation_polynomial</a> (double xn, double *fxn, double **coff, const double *x, const int ndata, const int npoints, const int *nlev)</td></tr>
<tr class="memdesc:a10270a1ba230322545fff5bc06d94659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermite interpolation polynomial.  <a href="#a10270a1ba230322545fff5bc06d94659">More...</a><br /></td></tr>
<tr class="separator:a10270a1ba230322545fff5bc06d94659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>For extrapolation related functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a92c709f3757c872402d2fcf954c3e2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c709f3757c872402d2fcf954c3e2de">&sect;&nbsp;</a></span>binomial_recursive_generator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::binomial_recursive_generator </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binomial coefficients generator. </p>
<p>Generate the next binomial sequence (n 1:n) based on (n-1 1:n-1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bp</td><td>n-1 sequence array (size of n-1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bn</td><td>new sequence array (size of n) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>new sequence index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0499a8ae6cab209fc0cca6a47b166f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0499a8ae6cab209fc0cca6a47b166f3">&sect;&nbsp;</a></span>extrapolation_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EP::extrapolation_error </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>Tn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Tsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error estimation. </p>
<p>Error calculation based on <img class="formulaInl" alt="$ T_{n,n} $" src="form_41.png"/> and <img class="formulaInl" alt="$ T_{n,n-1} $" src="form_42.png"/> Calculate the value of <img class="formulaInl" alt="$ 2 \frac{T_{n,n} - T_{n,n-1}}{\sqrt{T_{n,n}^2 + T_{n,n-1}^2}} $" src="form_43.png"/> via looping all Tsize data and select the maximum value as error </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Tn</td><td><img class="formulaInl" alt="$ T_{n,(1..n)} $" src="form_36.png"/> array (two dimensional array with size [n][Tsize], where first [] indicate the extrapolation order and second [] indicate individual data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tsize</td><td>data array size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>iteration step index (count from 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum error </dd></dl>

</div>
</div>
<a id="ac820e20bad3526991885e767a4e11097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac820e20bad3526991885e767a4e11097">&sect;&nbsp;</a></span>H_opt_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EP::H_opt_factor </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Next step optimized factor estimation (based on the extrapolation order n) </p>
<p>Calculate the modification factor for next extrapolation intergration step (assume next maximum extrapolation order is n). <br />
(new step size) Hnew ~ (old step size) H * (<em>exp/<em>err</em>)**1/</em>(2n+3) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>error of current extrapolation from <img class="formulaInl" alt="$ T_{n,n-1} $" src="form_42.png"/> to <img class="formulaInl" alt="$ T_{n,n} $" src="form_41.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exp</td><td>expected error </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>current extrapolation order (count from 0) return: optimized factor (H = H*factor) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bbde38ef63ce2a0672843d598770b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bbde38ef63ce2a0672843d598770b8">&sect;&nbsp;</a></span>Hermite_interpolation_coefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::Hermite_interpolation_coefficients </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>coff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double ***&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nlev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermite interpolation coefficients. </p>
<p>Generate Hermite interpolation polynomial coefficients (see example in <a href="https://en.wikipedia.org/wiki/Hermite_interpolation">https://en.wikipedia.org/wiki/Hermite_interpolation</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">coff</td><td>two dimensional array storing the interpolation coefficients [ndata][ <img class="formulaInl" alt="$\sum_j nlev_j$" src="form_44.png"/>] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>one dimensional array that store the positions [npoints] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>two dimensional array that store the f(x) [npoints][ndata] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>three dimensional array that store the f^(k)(x) [k][npoints][ndata] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndata</td><td>number of different type of data for interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npoints</td><td>number of position points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nlev</td><td>one dimensional array that store the maximum difference level for each position (f^(0)(x) count as 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10270a1ba230322545fff5bc06d94659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10270a1ba230322545fff5bc06d94659">&sect;&nbsp;</a></span>Hermite_interpolation_polynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::Hermite_interpolation_polynomial </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>coff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ndata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nlev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermite interpolation polynomial. </p>
<p>Return the interpolation result based on polynomial coefficients generated from <a class="el" href="namespaceEP.html#ad1bbde38ef63ce2a0672843d598770b8" title="Hermite interpolation coefficients. ">EP::Hermite_interpolation_coefficients()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xn</td><td>position want to get interpolation value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fxn</td><td>one dimensional array that store the interpolation results [ndata] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coff</td><td>two dimensional array storing the interpolation coefficients [ndata][ <img class="formulaInl" alt="$\sum_j nlev_j$" src="form_44.png"/>] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>one dimensional array that store the known positions [npoints]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndata</td><td>number of different type of data for interpolation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npoints</td><td>number of position points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nlev</td><td>one dimensional array that store the maximum difference level for each position (f^(0)(x) count as 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae89d6690a891336eef708e90e575a2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d6690a891336eef708e90e575a2be">&sect;&nbsp;</a></span>polynomial_extrapolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::polynomial_extrapolation </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>Tn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Tnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>step</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Tsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polynomial extrapolation of Tsize number of data together. </p>
<p>Iterate <img class="formulaInl" alt="$ T_{n,(1..n)} $" src="form_36.png"/> based on <img class="formulaInl" alt="$ T_{n-1,(1...n-1)} $" src="form_37.png"/> and <img class="formulaInl" alt="$ T_{n,1} $" src="form_38.png"/> Notice the Tsize number of data in <em>Tn</em> and <em>Tnew</em> are independent data that need to be extrapolated individually (each data is an individual <img class="formulaInl" alt="$ T_{x,x} $" src="form_39.png"/>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Tn</td><td>two dimensional array of <img class="formulaInl" alt="$ T_{n-1,(1...n-1)} $" src="form_37.png"/> (size of [n+1][Tsize]; first [] indicate the extrapolation order (1...n), second [] indicate the different data), will be updated to <img class="formulaInl" alt="$ T_{n,(1..n)} $" src="form_36.png"/> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Tnew</td><td>one dimensional array of <img class="formulaInl" alt="$ T_{n,1} $" src="form_38.png"/> (size of Tsize with different data), will be updated to <img class="formulaInl" alt="$ T_n $" src="form_40.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>step sequence (from sequence generators) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tsize</td><td>data array size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the new iteration step index in <em>step</em> (count from 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f951202841accc906325f37f9e592af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f951202841accc906325f37f9e592af">&sect;&nbsp;</a></span>polynomial_recursive_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EP::polynomial_recursive_formula </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ti1k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tik1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>hr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polynomial_recursion_formula. </p>
<p>Using Polynomial function: <img class="formulaInl" alt="$ T_{i,k} = T_{i,k-1} + \frac{T_{i,k-1} - T_{i-1,k-1}}{(h_{i-k}/h_i)^2 -1} $" src="form_27.png"/> <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ti1k1</td><td><img class="formulaInl" alt="$ t_{i-1,k-1} $" src="form_28.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tik1</td><td><img class="formulaInl" alt="$ t_{i,k-1} $" src="form_29.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hr</td><td><img class="formulaInl" alt="$ h_{i-k/h_i} $" src="form_30.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ T_{i,k} $" src="form_31.png"/> </dd></dl>

</div>
</div>
<a id="a069470acd4f6c52b2ebb68afcf4528ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069470acd4f6c52b2ebb68afcf4528ab">&sect;&nbsp;</a></span>rational_extrapolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::rational_extrapolation </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>Tn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Tnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>step</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>Tsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rational extrapolation of Tsize number of data together. </p>
<p>Iterate <img class="formulaInl" alt="$ T_{n,(1..n)} $" src="form_36.png"/> based on <img class="formulaInl" alt="$ T_{n-1,(1...n-1)} $" src="form_37.png"/> and <img class="formulaInl" alt="$ T_{n,1} $" src="form_38.png"/> <br />
Notice the Tsize number of data in <em>Tn</em> and <em>Tnew</em> are independent data that need to be extrapolated individually (each data is an individual <img class="formulaInl" alt="$ T_{x,x} $" src="form_39.png"/>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Tn</td><td>two dimensial array of <img class="formulaInl" alt="$ T_{n-1,(1...n-1)} $" src="form_37.png"/> (size of [n+1][Tsize]; first [] indicate the extrapolation order (1...n), second [] indicate the different data) will be updated to <img class="formulaInl" alt="$ T_{n,(1..n)} $" src="form_36.png"/> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Tnew</td><td>one dimensional array of <img class="formulaInl" alt="$ T_{n,1} $" src="form_38.png"/> (size of Tsize with different data), will be updated to <img class="formulaInl" alt="$ T_n $" src="form_40.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>step sequence (from sequence generators) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tsize</td><td>data array size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the new iteration step index in <em>step</em> (count from 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe6d08bb36343e39ebbbd4406dc9989f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6d08bb36343e39ebbbd4406dc9989f">&sect;&nbsp;</a></span>rational_recursive_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EP::rational_recursive_formula </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ti1k2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ti1k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tik1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>hr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rational_recursion formula. </p>
<p>Using rational function: <img class="formulaInl" alt="$ T_{i,k} = T_{i,k-1} + \frac{ T_{i,k-1} - T_{i-1,k-1} }{ \left( \frac{ h_{i-k} }{ h_i } \right)^2 \left( 1- \frac{ T_{i,k-1} - T_{i-1,k-1} }{ T_{i,k-1} - T_{i-1,k-2} } \right) -1} $" src="form_32.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ti1k2</td><td><img class="formulaInl" alt="$ T_{i-1,k-2} $" src="form_33.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ti1k1</td><td><img class="formulaInl" alt="$ T_{i-1,k-1} $" src="form_34.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tik1</td><td><img class="formulaInl" alt="$ T_{i,k-1} $" src="form_35.png"/> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hr</td><td><img class="formulaInl" alt="$ h_{i-k/h_i} $" src="form_30.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ T_{i,k} $" src="form_31.png"/> </dd></dl>

</div>
</div>
<a id="a1c85d6f300251929ac82736e54760652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c85d6f300251929ac82736e54760652">&sect;&nbsp;</a></span>seq_BS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::seq_BS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>itermax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Bulirsch &amp; Stoer sequence {h, h/2, h/3, h/4, h/6, h/8 ...}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>sequence array for storing the division steps {1, 2, 3, 4, 6 ...} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itermax</td><td>array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691e74f494e1137b68389a2bd93f92c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691e74f494e1137b68389a2bd93f92c0">&sect;&nbsp;</a></span>seq_Hairer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::seq_Hairer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>itermax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate E. Hairer (4k) sequences {h/2, h/6, h/10, h/14 ...}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>sequence array for storing the division steps {2, 6, 10, 14 ...} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itermax</td><td>array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6197a74bc7ca232ffcc84872d8f4f779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6197a74bc7ca232ffcc84872d8f4f779">&sect;&nbsp;</a></span>seq_Harmonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::seq_Harmonic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>itermax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Harmonic sequence {h, h/2, h/3, h/4 ...}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>sequence array for storing the division steps {1, 2, 3, 4 ...} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itermax</td><td>array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaef3617ed3fb4ad4627c19e955c5457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaef3617ed3fb4ad4627c19e955c5457">&sect;&nbsp;</a></span>seq_Romberg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EP::seq_Romberg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>itermax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Romberg (even) sequence {h, h/2, h/4, h/8 ...}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">step</td><td>sequence array for storing the division steps {1, 2, 4, 8 ...} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">itermax</td><td>array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEP.html">EP</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
