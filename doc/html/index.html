<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithmic Regularization Chain (ARC): ARC Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Algorithmic Regularization Chain (ARC)
   </div>
   <div id="projectbrief">Algorithmic Regularization Chain for few body motions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a> Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="AR_sec"></a>
Algorithmic Regularization (AR)</h1>
<p>The algorithm used in this code is based on the literatures of <a href="http://adsabs.harvard.edu/abs/1999MNRAS.310..745M">Mikkola &amp; Tanikawa (1999)</a> and <a href="http://adsabs.harvard.edu/abs/1999AJ....118.2532P">Preto &amp; Tremaine (1999)</a>. The development of this code refers to the Chapter 2 (Mikkola) in book <a href="http://www.springer.com/us/book/9781402084300">The Cambridge N-body Lectures</a>. Here the basic idea of AR is described.</p>
<p>The numerical simulations of gravitational N-body systems dynamical evolutions are frequently used in astrophysics. However, due to the singularity of two-body gravitational potential when these two particles become infinite close lead to the difficulty in the highly accurately integration of two-body bounded system with very high eccentricity. To get high accuracy of integration when two particles are very close, the time step for integration should be reduced significantly. This result in time consuming computation if number of particles is large. On the other hand, for a long-term integration, the total energy of the systems may be systematiclly drifted due to the numerical accuracy of integrators. Thus the sympletic methods are suggested to be used since it can keep the energy conservation for long-term integration.</p>
<p>However, the sympletic methods are difficult to be applied for gravitational systems due to the required time step (integration step) shrinking when two particle get close. Thus Mikkola &amp; Tanikawa (1999) and Preto &amp; Tremaine (1999) develop the special time transformation method based on the extended phase space Hamiltonian. The time <img class="formulaInl" alt="$t$" src="form_48.png"/> become a general coordinate in Hamiltonian with corresponding general momentum <img class="formulaInl" alt="$Pt$" src="form_26.png"/>. The integration of the equation of motion then depends on the new differential variable <img class="formulaInl" alt="$ s$" src="form_49.png"/>. In this case, time and the motion of the system can be integrated with a fixed step size of s, which allow the usage of sympletic methods.</p>
<h2><a class="anchor" id="H_sec"></a>
Hamiltonian in Extended Phase Space</h2>
<p>Defining the general coordinates as <img class="formulaInl" alt="$ \mathbf{q} = \{q_i\}, (i=1,n) $" src="form_50.png"/> with freedom of <img class="formulaInl" alt="$n$" src="form_51.png"/> and corresponding general momentums ad <img class="formulaInl" alt="$ \mathbf{p} $" src="form_52.png"/>, The Hamiltonian equations is:</p>
<p>(1) <img class="formulaInl" alt="$ \frac{d \mathbf{q}}{d t} = \frac{\partial H}{\partial \mathbf{p}}$" src="form_53.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{p}}{d t} = - \frac{\partial H}{\partial \mathbf{q}} $" src="form_54.png"/></p>
<p>Here the dt is used as a differetial varaible. For the propuse as we discussed above, we want to use a new variable <img class="formulaInl" alt="$s$" src="form_55.png"/> replacing the function of time <img class="formulaInl" alt="$t$" src="form_48.png"/>. In this case, the time is treated as a new general coordinate. And the corresponding time momentum <img class="formulaInl" alt="$Pt$" src="form_26.png"/> should be also added.</p>
<p>We extend the coordiantes to <img class="formulaInl" alt="$ \mathbf{Q} = (t, \mathbf{q}) $" src="form_56.png"/> and the momentums to <img class="formulaInl" alt="$ \mathbf{P} = (Pt, \mathbf{p})$" src="form_57.png"/> with total freedom of <img class="formulaInl" alt="$2(n+1)$" src="form_58.png"/>.</p>
<p>The new Hamiltonian <img class="formulaInl" alt="$H'$" src="form_59.png"/> should also satisfy the Hamiltonian equations (1). Especially for <img class="formulaInl" alt="$(t, Pt)$" src="form_60.png"/>, we can get:</p>
<p>(2) <img class="formulaInl" alt="$ \frac{d t}{d t} = \frac{\partial H'}{\partial Pt} = 1 $" src="form_61.png"/>; <img class="formulaInl" alt="$ \frac{d Pt}{d t} = - \frac{\partial H'}{\partial t} = - \frac{\partial H}{\partial t}$" src="form_62.png"/></p>
<p>From first equation of (2), we find the <img class="formulaInl" alt="$H'$" src="form_59.png"/> linearly depend on <img class="formulaInl" alt="$Pt$" src="form_26.png"/>, thus <img class="formulaInl" alt="$H'$" src="form_59.png"/> can be the form as <img class="formulaInl" alt="$ H' = H + Pt $" src="form_63.png"/>. The second equation indicates that the time evolution of <img class="formulaInl" alt="$Pt$" src="form_26.png"/> is equal to the negative energy change of the system. Thus the value of <img class="formulaInl" alt="$Pt$" src="form_26.png"/> at the time <img class="formulaInl" alt="$t$" src="form_48.png"/> can be <img class="formulaInl" alt="$-H(t)$" src="form_64.png"/>.</p>
<p>We want to write Hamiltonian equations with new differetial variable <img class="formulaInl" alt="$ ds$" src="form_65.png"/>. Defining <img class="formulaInl" alt="$ g(\mathbf{Q},\mathbf{P}) = \frac{dt}{ds} $" src="form_66.png"/>, we can rewrite (1) with <img class="formulaInl" alt="$ds$" src="form_67.png"/> and extended coordinates <img class="formulaInl" alt="$(\mathbf{Q}, \mathbf{P})$" src="form_68.png"/> as:</p>
<p>(3) <img class="formulaInl" alt="$ \frac{d \mathbf{Q}}{d s} = g(\mathbf{Q},\mathbf{P}) \frac{\partial H'}{\partial \mathbf{P}} $" src="form_69.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{P}}{d s} = - g(\mathbf{Q},\mathbf{P}) \frac{\partial H'}{\partial \mathbf{Q}} $" src="form_70.png"/></p>
<p>However, we need to have the Hamiltonian equations the same form as original, thus we need to find another Hamiltonian <img class="formulaInl" alt="$\Gamma(\mathbf{P},\mathbf{Q})$" src="form_71.png"/> that satisfy the Hamiltonian equations:</p>
<p>(4) <img class="formulaInl" alt="$ \frac{d \mathbf{Q}}{d s} = \frac{\partial \Gamma}{\partial \mathbf{P}} $" src="form_72.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{P}}{d s} = -\frac{\partial \Gamma}{\partial \mathbf{Q}} $" src="form_73.png"/></p>
<p>To find correct <img class="formulaInl" alt="$\Gamma(\mathbf{P},\mathbf{Q})$" src="form_71.png"/>, we go back to the Principle of least action which is used to derive the Lagrangian equations. The relation between (standard) Hamiltonian <img class="formulaInl" alt="$H(\mathbf{p},\mathbf{q},t)$" src="form_74.png"/> and Lagrangian <img class="formulaInl" alt="$L(\mathbf{p},\mathbf{q},t)$" src="form_75.png"/> is</p>
<p>(5) <img class="formulaInl" alt="$ H(\mathbf{p},\mathbf{q},t) = \sum_{i=1}^n p_i \dot{q_i} - L(\mathbf{p},\mathbf{q},t) $" src="form_76.png"/></p>
<p>The Principle of least action require the action</p>
<p>(6) <img class="formulaInl" alt="$ S = \int_{t_1}^{t_2} L(\mathbf{p},\mathbf{q},t) dt = \int_{t_1}^{t_2} \left[ \sum_{i=1}^n p_i \dot{q_i} - H(\mathbf{p},\mathbf{q},t) \right] dt $" src="form_77.png"/></p>
<p>should take the mimimum path, thus any function variation <img class="formulaInl" alt="$ \delta S $" src="form_78.png"/> should makes <img class="formulaInl" alt="$ S + \delta S$" src="form_79.png"/> increase. Thus when <img class="formulaInl" alt="$ \delta L(\mathbf{p},\mathbf{q},t) = 0 $" src="form_80.png"/>, this condition is satisfied. This leads to the Lagrangian equations and also the Hamitonian equations.</p>
<p>Here the integration takes from <img class="formulaInl" alt="$ t_1 $" src="form_81.png"/> to <img class="formulaInl" alt="$ t_2 $" src="form_82.png"/> and the time is used as integration variable. Now we treat <img class="formulaInl" alt="$(t, Pt)$" src="form_60.png"/> as new coordinate and momemtum, <img class="formulaInl" alt="$H'$" src="form_59.png"/> as new Hamitonian, and use <img class="formulaInl" alt="$s$" src="form_55.png"/> as new integration variable. Then <img class="formulaInl" alt="$S$" src="form_83.png"/> can be rewrited as:</p>
<p>(7) <img class="formulaInl" alt="$ S = \int_{s_1}^{s_2} \left[ \sum_{i=1}^n p_i \frac{d q_i} {d s} + Pt \frac{d t}{d s} - (H(\mathbf{p},\mathbf{q},t) + Pt) \frac{d t}{d s} \right] ds = \int_{s_1}^{s_2} \left[ \sum_{i=1}^{n+1} P_i \frac{d Q_i}{d s} - H'(\mathbf{P},\mathbf{Q}) \frac{d t}{d s}\right] ds $" src="form_84.png"/></p>
<p>It is obvious that when</p>
<p>(8) <img class="formulaInl" alt="$ \Gamma(\mathbf{P},\mathbf{Q}) = H'(\mathbf{P},\mathbf{Q}) \frac{d t}{d s} = g(\mathbf{Q},\mathbf{P}) (H(\mathbf{p},\mathbf{q},t) + Pt) $" src="form_85.png"/></p>
<p>The formula (7) become the same form as (6). Then with Principle of least action, the Hamiltonian equation (4) can be derived. We call the <img class="formulaInl" alt="$ \Gamma(\mathbf{P},\mathbf{Q}) $" src="form_86.png"/> is the Hamiltonian in the extended phase space <img class="formulaInl" alt="$ (\mathbf{P},\mathbf{Q}) $" src="form_87.png"/></p>
<p>The Hamiltonian in extended phase space <img class="formulaInl" alt="$\Gamma$" src="form_88.png"/> is also useful for analyzing the systems where Hamiltonian <img class="formulaInl" alt="$H$" src="form_89.png"/> explicitly depends on time and is not conserved. Since time become a coordinate in <img class="formulaInl" alt="$\Gamma$" src="form_88.png"/>, <img class="formulaInl" alt="$\frac{\partial \Gamma}{\partial s}$" src="form_90.png"/> is zero thus <img class="formulaInl" alt="$ \Gamma$" src="form_91.png"/> become conserved quantity. The method dealing with closed system can be used with Hamiltonian in extended phase space.</p>
<h2><a class="anchor" id="T_sec"></a>
Time transformation for Separable Hamiltonian</h2>
<p>With the Hamiltonian in extended phase space, we can integrate the equation of motions with step <img class="formulaInl" alt="$ ds $" src="form_92.png"/> by choosing a kind of <img class="formulaInl" alt="$g(\mathbf{Q},\mathbf{P})$" src="form_93.png"/>. If we choose a <img class="formulaInl" alt="$g(\mathbf{Q},\mathbf{P})$" src="form_93.png"/> that makes the Hamiltonian <img class="formulaInl" alt="$\Gamma(\mathbf{Q},\mathbf{P})$" src="form_94.png"/> separable for <img class="formulaInl" alt="$P$" src="form_95.png"/> and <img class="formulaInl" alt="$Q$" src="form_96.png"/>:</p>
<p>(9) <img class="formulaInl" alt="$ \Gamma(\mathbf{Q},\mathbf{P}) = a(\mathbf{P}) + b(\mathbf{Q}) $" src="form_97.png"/></p>
<p>Then explicit Leapfrog (SIA) integration method can be used. Preto &amp; Tremaine (1999) suggests to use</p>
<p>(10) <img class="formulaInl" alt="$ g(\mathbf{Q},\mathbf{P}) = \frac{f(T(\mathbf{P})) - f(-U(\mathbf{Q}))}{T(\mathbf{P}) + U(\mathbf{Q})} $" src="form_98.png"/></p>
<p>where <img class="formulaInl" alt="$ T(\mathbf{P}) = T(\mathbf{p}) + Pt $" src="form_99.png"/> is the extended kinetic energy and <img class="formulaInl" alt="$ U(\mathbf{Q}) = U(\mathbf{q},t) $" src="form_100.png"/> is the extended potential energy.</p>
<p>The Hamiltonian becomes separable:</p>
<p>(11) <img class="formulaInl" alt="$ \Gamma = f(T(\mathbf{P})) - f(-U(\mathbf{Q})) $" src="form_101.png"/></p>
<p>Then the equation of motions are:</p>
<p>(12) <img class="formulaInl" alt="$ \frac{d \mathbf{q} }{d s} = f'(T(\mathbf{p})+Pt) \frac{\partial T(\mathbf{p})}{\partial {\mathbf{p}}} $" src="form_102.png"/>; <img class="formulaInl" alt="$ \frac{d t }{d s} = f'(T(\mathbf{p})+Pt) $" src="form_103.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{p} }{d s} = f'(-U(\mathbf{q},t)) \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{q}}} $" src="form_104.png"/>; <img class="formulaInl" alt="$ \frac{d Pt}{d s} = f'(-U(\mathbf{q},t)) \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{t}}} $" src="form_105.png"/>;</p>
<p>where <img class="formulaInl" alt="$ f'(x) = \frac{d f(x)}{d x} $" src="form_106.png"/>.</p>
<p>Since <img class="formulaInl" alt="$Pt = -H(t)$" src="form_107.png"/>, <img class="formulaInl" alt="$H'=H+Pt = T(\mathbf{P}) + U(\mathbf{Q}) = 0 $" src="form_108.png"/>. Thus during integration, <img class="formulaInl" alt="$T(\mathbf{P}) \approx -U(\mathbf{Q}) $" src="form_109.png"/>. This requires <img class="formulaInl" alt="$ f(T(\mathbf{P})) - f(-U(\mathbf{Q})) \approx 0 $" src="form_110.png"/>. With Taylor expansion, we can obtain:</p>
<p>(13) <img class="formulaInl" alt="$ f(T(\mathbf{P})) = f(-U(\mathbf{Q})) + \left[T(\mathbf{P}) + U(\mathbf{Q})\right] f'(-U(\mathbf{Q})) + O\left[T(\mathbf{P}) + U(\mathbf{Q})\right]^2 $" src="form_111.png"/></p>
<p>Thus</p>
<p>(14) <img class="formulaInl" alt="$ g(\mathbf{Q},\mathbf{P}) \approx f'(-U(\mathbf{Q})) $" src="form_112.png"/></p>
<h3><a class="anchor" id="logH_sec"></a>
Logarithmic Hamintonian method (LogH)</h3>
<p>Mikkola &amp; Tanikawa (1999) suggests to use the function <img class="formulaInl" alt="$ f(x) = \log{x} $" src="form_113.png"/> (Logarithmic Hamintonian method). In this case, the time transformation based on (14) is:</p>
<p>(15) <img class="formulaInl" alt="$ g(\mathbf{Q},\mathbf{P}) \approx \frac{1}{-U(\mathbf{Q})} $" src="form_114.png"/></p>
<p>Then the equation of motions can be written as:</p>
<p>(16) <img class="formulaInl" alt="$ \frac{d \mathbf{q} }{d s} = \frac{1}{T(\mathbf{p})+Pt} \frac{\partial T(\mathbf{p})}{\partial {\mathbf{p}}} $" src="form_115.png"/>; <img class="formulaInl" alt="$ \frac{d t }{d s} = \frac{1}{T(\mathbf{p})+Pt} $" src="form_116.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{p} }{d s} = \frac{1}{-U(\mathbf{q},t)} \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{q}}} $" src="form_117.png"/>; <img class="formulaInl" alt="$ \frac{d Pt}{d s} = \frac{1}{-U(\mathbf{q},t)} \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{t}}} $" src="form_118.png"/>;</p>
<p>For the point mass systems with Newtonian gravity</p>
<p>(17) <img class="formulaInl" alt="$ T(\mathbf{p}) = \sum_{i=1}^{n} \frac{\mathbf{p_i}^2}{2m} $" src="form_119.png"/>; <img class="formulaInl" alt="$ U(\mathbf{q},t) = - \sum_{i&lt;j,i=1,j=1}^{i\rightarrow n,j\rightarrow n} \frac{G m_i m_j}{|\mathbf{q_i}-\mathbf{q_j}|} $" src="form_120.png"/></p>
<p>where G is gravitational constant and <img class="formulaInl" alt="$ m_i, m_j $" src="form_121.png"/> are masses of point-mass particles.</p>
<p>From (17) we see <img class="formulaInl" alt="$ \frac{d Pt}{d s} = 0 $" src="form_122.png"/>. This is only for the isolated system. If the system has external force from perturbers or external potential. The energy of system ( <img class="formulaInl" alt="$-Pt$" src="form_123.png"/>) may not be conserved any more. Thus the energy change should be added into <img class="formulaInl" alt="$Pt$" src="form_26.png"/> during the integration.</p>
<h3><a class="anchor" id="TTL_sec"></a>
Time-Transformed Leapfrog (TTL)</h3>
<p>The regularization methods where energy explicitly appear in the equation of motions cannot solve the few-body systems with large mass ratio (for example, planetary systems and super massive black hole with surrounding stars), because the energy is dominated by the massive bodies, and this introduce the systematic error during the integration. To solve this kind of issue, <a href="http://adsabs.harvard.edu/abs/2002CeMDA..84..343M">Mikkola &amp; Aarseth (2002)</a> developed the so-called Time-Transformed Leapfrog (TTL) method. This method is also based on time transformation. The major difference compared with the LogH method is that the time transformation function also need to be integrated.</p>
<p>The time transformation (10) leads to the equations of motion (12) where time transformation <img class="formulaInl" alt="$ f'(T(\mathbf{p})+Pt) $" src="form_124.png"/> and <img class="formulaInl" alt="$ f'(-U(\mathbf{q},t))$" src="form_125.png"/> explicitly depend on kinetic energy, binding energy and potential. If we want to replace <img class="formulaInl" alt="$ -U(\mathbf{q},t) $" src="form_126.png"/> to other quantity <img class="formulaInl" alt="$ W(\mathbf{q})$" src="form_127.png"/> (here <img class="formulaInl" alt="$ W(\mathbf{q})$" src="form_127.png"/> is positive), considering the requirement <img class="formulaInl" alt="$ f(T(\mathbf{P})) - f(-U(\mathbf{Q})) \approx 0 $" src="form_110.png"/>, we should also find another quantity <img class="formulaInl" alt="$ w(\mathbf{p}) $" src="form_128.png"/> that allow <img class="formulaInl" alt="$ f(w(\mathbf{p})) - f(W(\mathbf{q})) \approx 0 $" src="form_129.png"/>. and</p>
<p>(18) <img class="formulaInl" alt="$ g(\mathbf{Q},\mathbf{P}) = \frac{f(w(\mathbf{p})) - f(-W(\mathbf{q}))}{T(\mathbf{P}) + U(\mathbf{Q})} \approx f'(W(\mathbf{q})) $" src="form_130.png"/></p>
<p>Instead of finding the <img class="formulaInl" alt="$ w(\mathbf{p}) $" src="form_128.png"/> for each kind of <img class="formulaInl" alt="$ W(\mathbf{q})$" src="form_127.png"/>, Mikkola &amp; Aarseth (2002) suggest to use the differential equation</p>
<p>(19) <img class="formulaInl" alt="$ \frac{d W(\mathbf{q})}{d s} = \frac{\partial W(\mathbf{q})}{\partial \mathbf{q}} \cdot \frac{d \mathbf{q}} {d s} $" src="form_131.png"/></p>
<p>and integrate this equation to approximate <img class="formulaInl" alt="$ w(\mathbf{p}) = \int \frac{d W(\mathbf{q})}{d s} d s$" src="form_132.png"/> simultaneously with integration of <img class="formulaInl" alt="$ \frac{d \mathbf{p} }{d s} $" src="form_133.png"/>.</p>
<p>However</p>
<p>(20) <img class="formulaInl" alt="$ \frac{d \mathbf{q}}{d s} = \frac{d \mathbf{q}}{d t} \frac{d t}{d s} = \frac {\mathbf{p}}{m} f'(W(\mathbf{q}))$" src="form_134.png"/></p>
<p>Thus <img class="formulaInl" alt="$ \frac{d W(\mathbf{q})}{d s} $" src="form_135.png"/> explicitly depends on the momemtum. The integration in principle are not separatable. To solve this issue, Mikkole &amp; Aarseth (2002) recommend to use averaged momemtums <img class="formulaInl" alt="$ \langle \mathbf{p} \rangle $" src="form_136.png"/> (velocities) between previous and current step's during the Leapfrog integration, because the averaged values can represent the momemtums at the D (half) step when <img class="formulaInl" alt="$\mathbf{q}$" src="form_137.png"/> is integrated.</p>
<p>Then if we take <img class="formulaInl" alt="$ f(x) = \log{x}$" src="form_138.png"/> again, we have the equations of motion like:</p>
<p>(21) <img class="formulaInl" alt="$ \frac{d \mathbf{q} }{d s} = \frac{1}{w} \frac{\partial T(\mathbf{p})}{\partial {\mathbf{p}}} $" src="form_139.png"/>; <img class="formulaInl" alt="$ \frac{d t }{d s} = \frac{1}{w} $" src="form_140.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{p} }{d s} = \frac{1}{W(\mathbf{q})} \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{q}}} $" src="form_141.png"/>; <img class="formulaInl" alt="$ \frac{d w}{d s} = \frac{1}{W(\mathbf{q})} \frac{\partial W(\mathbf{q})}{\partial \mathbf{q}} \cdot \frac{\langle \mathbf{p} \rangle} {m} $" src="form_142.png"/>;</p>
<p>This solution avoid use the energy (potential) as a time transformation dependence, thus with a suitable choice of <img class="formulaInl" alt="$ W(\mathbf{q}) $" src="form_143.png"/>, the high mass ratio systems can be integrated with high accuracy.</p>
<h1><a class="anchor" id="code_sec"></a>
Implementation of ARC</h1>
<p>We implememted AR method together with Chain (discussed below) for few-body systems by using C++ programming Language. The idea is make the integrator a C++ class thus can be easily used as a module for other codes. In this section we describe the details of the implementation.</p>
<h2><a class="anchor" id="chain_sec"></a>
Particle Chain</h2>
<p>If the bounded few-body systems are inside a big cluster enviroment, the average distance between these particles can be much smaller than the scale of cluster. Thus the round off error can be large if the positions of these particles are in the cluster center-of-mass frame. To avoid this issue, <a href="http://adsabs.harvard.edu/abs/1993CeMDA..57..439M">Mikkola &amp; Aarseth (1993)</a> suggested to use Chain method.</p>
<p>The idea is to connect all particles in one chain and using relative position and velocity for integration. Firstly, one particle is selected as a starting point of the chain, then the nearest particle is selected as the next chain member, the relative position <img class="formulaInl" alt="$ X $" src="form_144.png"/> and velocity <img class="formulaInl" alt="$ V $" src="form_145.png"/> between these neighbors are calculated and stored. After that, we found the nearest particle to this second member from the remaining particles and calculate relative positions and velocites and do this iterately until all particles are connected in this chain. The relative positions and velocites can be described by absolute positions and velocities in a ordered chain as:</p>
<p>(22) <img class="formulaInl" alt="$ \mathbf{X}_i = \mathbf{q}_{i+1} - \mathbf{q}_i $" src="form_146.png"/>; <img class="formulaInl" alt="$ \mathbf{V}_i = \mathbf{v}_{i+1} - \mathbf{v}_i $" src="form_147.png"/></p>
<p>The integration is done with these relative quantities to reduce round off error. The equations of motion can be written as</p>
<p>(23) <img class="formulaInl" alt="$ \frac{d \mathbf{X}_i}{d t} = \mathbf{V}_i $" src="form_148.png"/>; <img class="formulaInl" alt="$ \frac{d \mathbf{V}_i}{d t} = \mathbf{A}_{i+1} - \mathbf{A}_i $" src="form_149.png"/></p>
<p>where <img class="formulaInl" alt="$ \mathbf{A}_i $" src="form_150.png"/> is the acceleration of particle <img class="formulaInl" alt="$ i$" src="form_151.png"/>.</p>
<p>When the particles are moved, the nearest neighbor of each particle may become different, thus the update of chain order should be performed with a suitable time interval.</p>
<h2><a class="anchor" id="leap_sec"></a>
Leapfrog Integrator</h2>
<p>By combining the AR algorithm and Chain scheme, we can construct a Leapfrog integrator of equations of motion for $N$-body systems like:</p><ul>
<li>D mode:</li>
</ul>
<p>(24) <img class="formulaInl" alt="$ \Delta t = \Delta s / (\alpha (T(\mathbf{p}) + Pt) + \beta w + \gamma) $" src="form_152.png"/>; <img class="formulaInl" alt="$ t += \Delta t $" src="form_153.png"/>; <img class="formulaInl" alt="$ \mathbf{X}_i += \Delta t \mathbf{V}_i $" src="form_154.png"/></p>
<ul>
<li>K mode:</li>
</ul>
<p>(25) <img class="formulaInl" alt="$ \delta t = \Delta s / (\alpha U(\mathbf{q},t) + \beta W(\mathbf{q}) + \gamma) $" src="form_155.png"/>; <img class="formulaInl" alt="$ \mathbf{V}_i += \delta t (\mathbf{A}_{i+1} - \mathbf{A}_{i}) $" src="form_156.png"/>; <img class="formulaInl" alt="$ Pt += \delta t \sum_i (-m_i \langle \mathbf{v}_i \rangle \cdot f_{ext,i}) $" src="form_157.png"/>; <img class="formulaInl" alt="$ w += \delta t \sum_i \frac{\partial W}{\partial \mathbf{q}_i} \cdot \langle \mathbf{v}_i \rangle $" src="form_158.png"/></p>
<p>where <img class="formulaInl" alt="$ f_{ext,i} $" src="form_159.png"/> is the external force from outside the system (e.g., perturber force or tidal force) of each particle <img class="formulaInl" alt="$ i$" src="form_151.png"/>, and <img class="formulaInl" alt="$ \langle \mathbf{v}_i \rangle$" src="form_160.png"/> is obtained by averaging the velocities of the initial and the final <img class="formulaInl" alt="$ \mathbf{v}_i $" src="form_161.png"/> of this K mode step. <img class="formulaInl" alt="$ \alpha, \beta, \gamma $" src="form_162.png"/> are the coefficients representing the weights of the LogH, TTL and non-time-transformation modes separately. For example, if <img class="formulaInl" alt="$ \alpha=0$" src="form_163.png"/>, then no LogH will be performed, and if <img class="formulaInl" alt="$ \alpha =1, \beta=0, \gamma=0 $" src="form_164.png"/> it is LogH <a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a>.</p>
<p>The initial value of <img class="formulaInl" alt="$ Pt $" src="form_165.png"/> should be the initial binding energy of the system <img class="formulaInl" alt="$ U(\mathbf{q},t) - T(\mathbf{p}) $" src="form_166.png"/>. If the system is isolated, <img class="formulaInl" alt="$ Pt $" src="form_165.png"/> is constant. The initial value of <img class="formulaInl" alt="$ w$" src="form_167.png"/> is set to initial <img class="formulaInl" alt="$ W(\mathbf{q}) $" src="form_143.png"/>.</p>
<p>The Leapfrog step start with half-step D and then loop full-step K-D-K and stop with half-step D:</p>
<p>(26) <img class="formulaInl" alt="$ D(\Delta s/2)K(\Delta s)D(\Delta s)....K(\Delta s)D(\Delta s/2) $" src="form_168.png"/></p>
<p>This provide a second order integrator of <a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a>. Trying this integrator for a two-body bounded system can result in an energy and eccentricity conserved kepler orbit. Only the time phase can have cumulative error after long-term integration.</p>
<h2><a class="anchor" id="extrapolation_sec"></a>
Extrapolation Integrator</h2>
<p>The Leapfrog integrator only has second order accuracy, which is not enough for many applications. One can reduce the step size of integration to obtain higher accuracy. However, as energy is always conserved for two-body motions, we don't have good checker to indicate whether the integration is accurate enough. A better and more efficient way is to extrapolate the integration results to infinite small step <img class="formulaInl" alt="$ \Delta s\approx 0$" src="form_169.png"/>, thus the high accuracy result can be obtained. The idea of extrapolation integration is well summarized in <a href="http://link.springer.com/book/10.1007%2F978-0-387-21738-3">Stoer &amp; Bulirsch</a>. Here the basic algorithm is shown.</p>
<p>First, if we integrate the equations of motion with Leapfrog integrator by step <img class="formulaInl" alt="$ \Delta s$" src="form_170.png"/>. we get the first result with a certain accuracy. Now we keep the total step constant but divide the integration into several sub-steps with equal sizes by <img class="formulaInl" alt="$ n $" src="form_171.png"/>, we can obtain higher accuracy of the integration. When we use a sequence of dividers <img class="formulaInl" alt="$ (n_1, n_2, n_3 ...)$" src="form_172.png"/> ( <img class="formulaInl" alt="$ n_{i+1}&gt;n_i$" src="form_173.png"/>) and do the integration with each of them, we can obtain a series of results with increasing accuracy. Then we can extrapolate these results to obtain the value of <img class="formulaInl" alt="$ \Delta s/n_{\infty}=0 $" src="form_174.png"/>.</p>
<p>There are two major methods of extrapolation: polynomial and rational. Both methods can be described as recursive functions:</p>
<ul>
<li>Polynomial:</li>
</ul>
<p>(27) <img class="formulaInl" alt="$ T_{i,k} = T_{i,k-1} + \frac{T_{i,k-1} - T_{i-1,k-1}}{( h_{i-k} / {h_i} )^2 -1} $" src="form_175.png"/>, <img class="formulaInl" alt="$ 1 \le k \le i \le m $" src="form_176.png"/></p>
<ul>
<li>Rational:</li>
</ul>
<p>(28) <img class="formulaInl" alt="$ T_{i,k} = T_{i,k-1} + \frac{T_{i,k-1} - T_{i-1,k-1}}{\left[ \frac{h_{i-k}}{h_i} \right]^2 \left[ 1 - \frac{T_{i,k-1} - T_{i-1,k-1}}{T_{i,k-1}- T_{i-1,k-2}} \right]-1} $" src="form_177.png"/>, <img class="formulaInl" alt="$ 1 \le k \le i \le m $" src="form_176.png"/></p>
<p>Here <img class="formulaInl" alt="$ i$" src="form_151.png"/> indicate the integration with sub-step size <img class="formulaInl" alt="$ h_i = s/n_i$" src="form_178.png"/>, and <img class="formulaInl" alt="$ k $" src="form_179.png"/> indicate the extrapolation order. The <img class="formulaInl" alt="$ T_{i,0} $" src="form_180.png"/> are results of Leapfrog integrations, and for each order <img class="formulaInl" alt="$ i$" src="form_151.png"/>, the <img class="formulaInl" alt="$ T_{i,i} $" src="form_181.png"/> is final extrapolation result we want. The <img class="formulaInl" alt="$ T_{i,i} $" src="form_181.png"/> can be obtained by calculating <img class="formulaInl" alt="$ T_{i,k} $" src="form_34.png"/> from <img class="formulaInl" alt="$ k=1 $" src="form_182.png"/> to <img class="formulaInl" alt="$ k=i $" src="form_183.png"/> using the recursive functions.</p>
<p>One benefit of these recursive functions is that a higher order extrapolation <img class="formulaInl" alt="$ T_{i+1,i+1} $" src="form_184.png"/> can be established based on current existing <img class="formulaInl" alt="$ T_{i,k}, k=0\sim i $" src="form_185.png"/> with a new higher order integration result <img class="formulaInl" alt="$ T_{i+1,0} $" src="form_186.png"/>. Then it is easy to estimate the error by comparing <img class="formulaInl" alt="$ T_{i+1,i+1} $" src="form_184.png"/> and <img class="formulaInl" alt="$ T_{i,i} $" src="form_181.png"/> to determine whether another higher order result is necessary. For example, in <a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a> integration, we can check the time or position phase error and energy error to determine how many orders we need to integrate and extrapolate due to the accuracy requirment.</p>
<p>The sequences of dividers <img class="formulaInl" alt="$ n_i $" src="form_187.png"/> have several choices for different applications:</p><ul>
<li><a href="https://en.wikipedia.org/wiki/Romberg&apos;s_method">Romberg</a>: (1, 2, 4, 8 ...)</li>
<li><a href="http://link.springer.com/article/10.1007%2FBF02165234">Bulirsch &amp; Stoer</a> (BS): (1, 2, 3, 4, 6, 8 ...)</li>
<li><a href="http://link.springer.com/article/10.1007%2FBF01385634">Hairer</a> (4k): (2, 6, 10, 14 ...)</li>
<li>Harmonic: (1, 2, 3, 4 ...)</li>
</ul>
<p>Different seuqnces and recursive functions can be combined together for extrapolation integration. We implement all sequences shown above. Later we discuss the special application of some sequences.</p>
<h2><a class="anchor" id="dense_sec"></a>
Dense Output for Time Synchronization</h2>
<p>Although the <a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a> can make the integration of $N$-body systems accurately, the side-effect of time transformation is that the physical time become unpredictable. With the Leapfrog integrator, we cannot know what will be the final physical time before one integration step finish. This result in difficulty if we want to use the <a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a> together with a $N$-body code to simulate a particle cluster including dense sub-systems. The integration of the motions of particles surrounding this sub-system need to obtain the acceleration from this sub-system at a certain physical time, but with <a class="el" href="namespaceARC.html" title="Algorithmic regularization chain (ARC) namespace. ">ARC</a> the integration of this sub-system cannot exactly reach the required time. Especially with extrapolation method, the large integration step is used frequently, thus the physical time error can be significant.</p>
<p>To solve this issue, we apply the dense output of extrapolation method introduced by <a href="http://link.springer.com/article/10.1007%2FBF01385634">Hairer &amp; Ostermann (1990)</a>. The idea of this scheme is using interpolation to obtain the integrated variable at any sub-step inside an extrapolation integration step. The interpolation should have the similar order of accuracy as the extrapolation and the internal integration results during extrapolation should be used for interpolation to save computational effort.</p>
<p>The physical time <img class="formulaInl" alt="$ t$" src="form_188.png"/> as a function of integration step variable <img class="formulaInl" alt="$ s $" src="form_189.png"/> then can be interpolated as <img class="formulaInl" alt="$ T(s) $" src="form_190.png"/>. If the required ending physical time <img class="formulaInl" alt="$ t_{off} $" src="form_191.png"/> is inside one integration step, we can solve the equation <img class="formulaInl" alt="$ T(s)=t_{off} $" src="form_192.png"/> to obtain the correct step size <img class="formulaInl" alt="$\Delta s_{off} $" src="form_193.png"/> to reach the exact <img class="formulaInl" alt="$ t_{off} $" src="form_191.png"/>. Then by redoing this integration step with <img class="formulaInl" alt="$\Delta s_{off}$" src="form_194.png"/>, we can get correct results.</p>
<p>One can also try to do dense ouput for all variables ( <img class="formulaInl" alt="$t$" src="form_48.png"/>, <img class="formulaInl" alt="$Pt$" src="form_26.png"/>, <img class="formulaInl" alt="$w$" src="form_28.png"/>, <img class="formulaInl" alt="$\mathbf{q}$" src="form_137.png"/>, <img class="formulaInl" alt="$\mathbf{p}$" src="form_195.png"/>), thus the results at correct physical time can be directly calculated instead of redoing the integration. However, as the computation of dense output is quite heavy (many extrapolation is needed; see below), redoing the integration can be cheaper if particle number is not large ( <img class="formulaInl" alt="$&lt;=4$" src="form_196.png"/>).</p>
<p>Hairer &amp; Ostermann (1990) introduced two dense output methods. One is for explicit Euler integrator using Harmonic sequences and another is for Gragg-Bulirsch-Stoer (GBS) method with 4k sequences (shown above). Here the brief algorithms are shown without mathematical proof.</p>
<h3><a class="anchor" id="euler_dense_sec"></a>
Dense Output for explicit Euler</h3>
<p>If the integrated variable is <img class="formulaInl" alt="$ y $" src="form_197.png"/> and its first derivate (acceleration) is <img class="formulaInl" alt="$ f $" src="form_198.png"/> which can be calculated directly, we can use explicit Euler together with Harmonic sequence <img class="formulaInl" alt="$ n_i = i$" src="form_199.png"/> for extrapolation. Then during each integration step, we have the initial <img class="formulaInl" alt="$ y_i(0) $" src="form_200.png"/> and the final <img class="formulaInl" alt="$ y_i(\Delta s) $" src="form_201.png"/>. In addition, <img class="formulaInl" alt="$ f_i(\Delta s* k/n_i) (k=0,n_i)$" src="form_202.png"/> are also calculated. Thus we can obtain the high order derivates of <img class="formulaInl" alt="$ f_i $" src="form_203.png"/> at the left and right edges using forward and backward differences:</p>
<p>(29) <img class="formulaInl" alt="$ f_i^{(k)}(0) = \left[\frac{n_i}{\Delta s}\right]^k \sum_{j=0}^k (-1)^j B_j^k f( \Delta s*\frac{k-j}{n_i}) $" src="form_204.png"/>; <img class="formulaInl" alt="$ f_i^{(k)}(\Delta s) = \left[\frac{n_i}{\Delta s}\right]^k \sum_{j=0}^k (-1)^j B_j^k f(\Delta s*(1-\frac{j}{n_i})) $" src="form_205.png"/>; <img class="formulaInl" alt="$(k=1, n_i) $" src="form_206.png"/></p>
<p>where <img class="formulaInl" alt="$ B_j^k = \frac{j!}{k!(j-k)!}$" src="form_207.png"/> is the binomial sequence.</p>
<p>Then if the last sequence index used in extrapolation is <img class="formulaInl" alt="$i=\kappa$" src="form_208.png"/>, the maximum order of derivate is <img class="formulaInl" alt="$ n_\kappa$" src="form_209.png"/>. Besides, for each order of derivate <img class="formulaInl" alt="$ f_i^{(k)}(0) $" src="form_210.png"/> and <img class="formulaInl" alt="$ f_i^{(k)}(\Delta s)$" src="form_211.png"/> ( <img class="formulaInl" alt="$ k=1,n_\kappa$" src="form_212.png"/>), we also have the values of different order of accuracy corresponding to difference step size <img class="formulaInl" alt="$(\Delta s/n_i)$" src="form_213.png"/> ( <img class="formulaInl" alt="$ i=k,n_\kappa$" src="form_214.png"/>). Thus the extrapolation can be done with these different order of accuracy (the same way as the extrapolation of <img class="formulaInl" alt="$y(\Delta s)$" src="form_215.png"/>) to get high accurate derivates <img class="formulaInl" alt="$f^{(k)}(0)$" src="form_216.png"/> and <img class="formulaInl" alt="$f^{(k)}(\Delta s)$" src="form_217.png"/>.</p>
<p>Since now the <img class="formulaInl" alt="$ y(0)$" src="form_218.png"/>, <img class="formulaInl" alt="$y(\Delta s)$" src="form_215.png"/>, <img class="formulaInl" alt="$f^{(k)}(0)$" src="form_216.png"/> and <img class="formulaInl" alt="$f^{(k)}(\Delta s)$" src="form_217.png"/> are avaiable, then Hermite interpolation can be used to get the interpolation polynomial function <img class="formulaInl" alt="$ Y(x) $" src="form_219.png"/> and</p>
<p>(30) <img class="formulaInl" alt="$ Y(x) - y(x) = O(\Delta s^{n_\kappa+1}) $" src="form_220.png"/></p>
<p>where <img class="formulaInl" alt="$ n_\kappa = \kappa $" src="form_221.png"/> in the case of Harmonic sequence.</p>
<h3><a class="anchor" id="gbs_dense_sec"></a>
Dense Output for Gragg-Bulirsch-Stoer</h3>
<p>Similar as the dense output method described above, for mordified middle point integrator used in GBS method, we can construct the interpolation using high order derivates of <img class="formulaInl" alt="$ f $" src="form_198.png"/> at the middle position ( <img class="formulaInl" alt="$\Delta s/2$" src="form_222.png"/>) instead of edges. However, differing from the edge differences, the middle difference is sensitive to the data point number. If <img class="formulaInl" alt="$ n_i$" src="form_223.png"/> is even, to obtain the derivate order with odd <img class="formulaInl" alt="$ k $" src="form_179.png"/> (which means <img class="formulaInl" alt="$k+1$" src="form_224.png"/> points are needed), we have to use values every two sub-steps.</p>
<p>For example, when <img class="formulaInl" alt="$ n_i = 6 $" src="form_225.png"/>, there are 6 sub-steps and 7 points ( <img class="formulaInl" alt="$ \Delta s*j/n_i $" src="form_226.png"/> with <img class="formulaInl" alt="$j=0,6$" src="form_227.png"/>). If <img class="formulaInl" alt="$ k = 3 $" src="form_228.png"/>, 4 points are needed to obtain the derivate <img class="formulaInl" alt="$ f_i^{(3)}(\Delta s/2) $" src="form_229.png"/>. Since we need the derivate at <img class="formulaInl" alt="$ \Delta s/2 $" src="form_230.png"/>, only <img class="formulaInl" alt="$ f $" src="form_198.png"/> at <img class="formulaInl" alt="$ j = 0,2,4,6 $" src="form_231.png"/> can be used. If <img class="formulaInl" alt="$ k = 4 $" src="form_232.png"/>, values at <img class="formulaInl" alt="$ j= 1,2,3,4,5$" src="form_233.png"/> are OK. But the difference step sizes in this case are different for odd and even <img class="formulaInl" alt="$ k$" src="form_234.png"/>.</p>
<p>To keep accuracy order consistent, we only allow every two points to be used for both odd and even order of derivates. The formular then should be</p>
<p>(31) <img class="formulaInl" alt="$ f_i^{(k)}(\Delta s/2) = \left[ \frac{2n_i}{\Delta s} \right]^k \sum_{j=0}^k (-1)^j B_j^k f(\Delta s*(\frac{1}{2}+\frac{z_j-2j}{n_i})) $" src="form_235.png"/>; <img class="formulaInl" alt="$ k=1,2i-1 $" src="form_236.png"/></p><ul>
<li>if <img class="formulaInl" alt="$k$" src="form_237.png"/> is odd, <img class="formulaInl" alt="$ z_j = k+1 $" src="form_238.png"/></li>
<li>if <img class="formulaInl" alt="$k$" src="form_237.png"/> is even, <img class="formulaInl" alt="$ z_j = k $" src="form_239.png"/></li>
</ul>
<p>together with the 4k sequence <img class="formulaInl" alt="$ n_i =(2, 6, 10, 14 ...) $" src="form_240.png"/>.</p>
<p>Then again the extrapolation of the derivates and also the middle point integrated variable <img class="formulaInl" alt="$ y(\Delta s/2) $" src="form_241.png"/> can be done and <img class="formulaInl" alt="$ y(0) $" src="form_242.png"/>, <img class="formulaInl" alt="$ y(\Delta s) $" src="form_243.png"/>, <img class="formulaInl" alt="$ y(\Delta s/2) $" src="form_241.png"/> and derivates <img class="formulaInl" alt="$ f^{(k)}(\Delta s/2) $" src="form_244.png"/> ( <img class="formulaInl" alt="$ k =1,2\kappa-1 $" src="form_245.png"/>) are avaiable for Hermite interpolation. This method can provide the interpolation polynomial function with accuracy</p>
<p>(32) <img class="formulaInl" alt="$ Y(x) - y(x) = O(\Delta s^{2\kappa-1}) $" src="form_246.png"/></p>
<h2><a class="anchor" id="step_sec"></a>
Integration Step Control</h2>
<p>If we use the automatical accuracy order in extrapolation integration (the maximum sequence index <img class="formulaInl" alt="$\kappa $" src="form_247.png"/> is determined by the error criterion), the step size <img class="formulaInl" alt="$\Delta s$" src="form_248.png"/> can be constant with a suitable initial value. On the other hand, <img class="formulaInl" alt="$ \Delta s$" src="form_170.png"/> can be also adjusted based on integration error to approach better performance.</p>
<p>The integration error at sequence index <img class="formulaInl" alt="$ i$" src="form_151.png"/> can be estimated as</p>
<p>(33) <img class="formulaInl" alt="$ err_i = \frac{2|T_{i,i-1} - T_{i,i}|}{\sqrt{T_{i,i-1}^2 + T_{i,i}^2}}$" src="form_249.png"/></p>
<p>If we want the expected error appear at sequence index <img class="formulaInl" alt="$ i$" src="form_151.png"/> after the next integration step, the step modification factor can be estimated as:</p>
<p>(34) <img class="formulaInl" alt="$ \frac{\Delta s_{new,i}}{\Delta s} \approx \left(\frac{exp}{err_{i}}\right)^{1/(2i-1)} $" src="form_250.png"/></p>
<p>with the assumption <img class="formulaInl" alt="$ err_i \propto (\Delta s)^{2i-1} $" src="form_251.png"/>. To determine which <img class="formulaInl" alt="$ i$" src="form_151.png"/> is best for performance, the computational effort</p>
<p>(35) <img class="formulaInl" alt="$ C_i = \frac{\sum_{k=0}^i n_i}{\Delta s_{new,i}} $" src="form_252.png"/></p>
<p>is calculated for each <img class="formulaInl" alt="$ i $" src="form_253.png"/>, then we choose index <img class="formulaInl" alt="$ i=k $" src="form_254.png"/> which corresponds to the mimimum <img class="formulaInl" alt="$ C_i $" src="form_255.png"/>. The next step is <img class="formulaInl" alt="$ \Delta s_{new,i} $" src="form_256.png"/>. This method should work with fixed accuracy order ( <img class="formulaInl" alt="$ \kappa $" src="form_257.png"/> is constant).</p>
<h2><a class="anchor" id="perf_sec"></a>
Performance Analysis</h2>
<p>Here the performance analysis of the code is provided. For one step of Leapfrog integration, we need two half-step integration of <img class="formulaInl" alt="$ \mathbf{q} $" src="form_258.png"/> and <img class="formulaInl" alt="$ t $" src="form_259.png"/>, one full-step integration of <img class="formulaInl" alt="$ \mathbf{p} $" src="form_52.png"/>, <img class="formulaInl" alt="$ Pt $" src="form_165.png"/> and <img class="formulaInl" alt="$ w $" src="form_260.png"/>. Before <img class="formulaInl" alt="$ \mathbf{p} $" src="form_52.png"/> is integrated, the acceleration <img class="formulaInl" alt="$ \mathbf{A} $" src="form_261.png"/> is calculated. If the particle number is <img class="formulaInl" alt="$ N $" src="form_262.png"/>, the computational cost is:</p>
<p>(35) <img class="formulaInl" alt="$ C_{LF} = C_{A,P}*N^2 + C_{Pt}*N + C_{w}*N + 2C_{p}*N + 2*C_{t} + C_{T}*N $" src="form_263.png"/></p>
<p>where <img class="formulaInl" alt="$ C_* $" src="form_264.png"/> correspond to the number of operations of different parts. If there is no perturbation and external force, <img class="formulaInl" alt="$ Pt $" src="form_165.png"/> is constant and <img class="formulaInl" alt="$ C_{Pt} = 0$" src="form_265.png"/>. If TTL method is switched off, <img class="formulaInl" alt="$ C_{w} = 0$" src="form_266.png"/>.</p>
<p>During the extrapolation integration, the Leapfrog integration is performed many times. After integration finished at each sequence <img class="formulaInl" alt="$ n_i $" src="form_187.png"/>, the extrapolation is performed. Thus the total cost is:</p>
<p>(36) <img class="formulaInl" alt="$ C_{EINT} = \sum_{i=1}^\kappa n_i*(C_{LF} + C_{EX}*(6N+3))$" src="form_267.png"/></p>
<p>where <img class="formulaInl" alt="$ C_{EX} $" src="form_268.png"/> is the number of operations of (polynomial or rational) extrapolation function. The <img class="formulaInl" alt="$ (6N+3) $" src="form_269.png"/> includes the variables of <img class="formulaInl" alt="$ t $" src="form_259.png"/>, <img class="formulaInl" alt="$ Pt $" src="form_165.png"/>, <img class="formulaInl" alt="$ w $" src="form_260.png"/>, <img class="formulaInl" alt="$ \mathbf{q} $" src="form_258.png"/> and <img class="formulaInl" alt="$ \mathbf{p} $" src="form_52.png"/>.</p>
<p>For the dense output, the high order derivates of <img class="formulaInl" alt="$ dt/ds $" src="form_270.png"/> and their extrapolation are calculated. The cost is:</p>
<p>(37) <img class="formulaInl" alt="$ C_{DEN} = \sum_{i=1}^\kappa \sum_{j=1}^{2i-1} [2j*C_{DIFF} + C_{EX}] $" src="form_271.png"/></p>
<p>where <img class="formulaInl" alt="$ C_{DIFF} $" src="form_272.png"/> is the number of operations for adding one <img class="formulaInl" alt="$ f(x) $" src="form_273.png"/> value during the computation of difference (31). For the two dense output methods discussed Section <a class="el" href="index.html#dense_sec">Dense Output for Time Synchronization</a>, the cost formula is similar (but the <img class="formulaInl" alt="$ \kappa $" src="form_257.png"/> can be significant difference in practice).</p>
<p>As we discussed in Section <a class="el" href="index.html#dense_sec">Dense Output for Time Synchronization</a>, we can do interpolation for all variables and the cost of dense output is <img class="formulaInl" alt="$ C_{DEN}*(6N+3) $" src="form_274.png"/>. Then the cost of dense output over extrapolation integration is</p>
<p>(38) <img class="formulaInl" alt="$ \frac{C_{DEN}}{C_{EINT}} \approx \frac{O(\kappa^3)}{O(\langle n_i\rangle*N)} $" src="form_275.png"/></p>
<p>where <img class="formulaInl" alt="$\langle n_i\rangle$" src="form_276.png"/> is the average <img class="formulaInl" alt="$ n_i $" src="form_187.png"/> from <img class="formulaInl" alt="$ i=1,\kappa$" src="form_277.png"/>. In the case of 4k sequence, <img class="formulaInl" alt="$\langle n_i\rangle \propto \kappa$" src="form_278.png"/>. The value of <img class="formulaInl" alt="$\kappa$" src="form_279.png"/> depends on the computational error criterion and the integration step size <img class="formulaInl" alt="$ \Delta s$" src="form_170.png"/>. Usually <img class="formulaInl" alt="$ \kappa&gt;4 $" src="form_280.png"/>, thus if <img class="formulaInl" alt="$ N $" src="form_262.png"/> is not large ( <img class="formulaInl" alt="$ N &lt; 5 $" src="form_281.png"/>), the full dense output with all variables is can be more computational expensive. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
